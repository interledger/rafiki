type Query {
  outgoingPayment(id: String!): OutgoingPayment

  account(id: String!): Account

  peer(id: String!): Peer

  "Fetch a page of peers."
  peers(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): PeersConnection!
}

type Mutation {
  createOutgoingPayment(
    input: CreateOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Requote a Cancelled payment."
  requoteOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Send a Ready payment."
  sendOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Cancel a Ready payment."
  cancelOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!

  createAccount(input: CreateAccountInput!): CreateAccountMutationResponse!

  "Create peer"
  createPeer(input: CreatePeerInput!): CreatePeerMutationResponse!

  "Update peer"
  updatePeer(input: UpdatePeerInput!): UpdatePeerMutationResponse!

  "Delete peer"
  deletePeer(id: String!): DeletePeerMutationResponse!

  "Transfer between accounts"
  transfer(
    sourceAmount: UInt64!
    sourceAccountId: ID!
    destinationAccountId: ID!
    destinationAmount: UInt64
    autoCommit: Boolean
    idempotencyKey: ID!
  ): TransferMutationResponse

  "Add peer liquidity"
  addPeerLiquidity(input: AddPeerLiquidityInput!): LiquidityMutationResponse

  "Add asset liquidity"
  addAssetLiquidity(input: AddAssetLiquidityInput!): LiquidityMutationResponse

  "Create liquidity withdrawal from peer"
  createPeerLiquidityWithdrawal(
    input: CreatePeerLiquidityWithdrawalInput!
  ): LiquidityMutationResponse

  "Create liquidity withdrawal from asset"
  createAssetLiquidityWithdrawal(
    input: CreateAssetLiquidityWithdrawalInput!
  ): LiquidityMutationResponse

  "Finalize liquidity withdrawal"
  finalizeLiquidityWithdrawal(
    "The id of the liquidity withdrawal to finalize."
    withdrawalId: String!
  ): LiquidityMutationResponse

  "Rollback liquidity withdrawal"
  rollbackLiquidityWithdrawal(
    "The id of the liquidity withdrawal to rollback."
    withdrawalId: String!
  ): LiquidityMutationResponse
}

type PageInfo {
  "Paginating forwards: the cursor to continue."
  endCursor: String
  "Paginating forwards: Are there more pages?"
  hasNextPage: Boolean!
  "Paginating backwards: Are there more pages?"
  hasPreviousPage: Boolean!
  "Paginating backwards: the cursor to continue."
  startCursor: String
}

type PeersConnection {
  pageInfo: PageInfo!
  edges: [PeerEdge!]!
}

type PeerEdge {
  node: Peer!
  cursor: String!
}

input CreatePeerInput {
  maxPacketAmount: UInt64
  http: HttpInput!
  asset: AssetInput!
  staticIlpAddress: String!
}

input UpdatePeerInput {
  id: String!
  maxPacketAmount: UInt64
  http: HttpInput
  staticIlpAddress: String
}

input HttpInput {
  incoming: HttpIncomingInput
  outgoing: HttpOutgoingInput!
}

input HttpIncomingInput {
  authTokens: [String!]!
}

input HttpOutgoingInput {
  authToken: String!
  endpoint: String!
}

input AssetInput {
  code: String!
  scale: Int!
}

input AddPeerLiquidityInput {
  "The id of the peer to add liquidity."
  peerId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input AddAssetLiquidityInput {
  "The id of the asset to add liquidity."
  assetId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input CreatePeerLiquidityWithdrawalInput {
  "The id of the peer to create the withdrawal for."
  peerId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

input CreateAssetLiquidityWithdrawalInput {
  "The id of the asset to create the withdrawal for."
  assetId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

type Asset {
  code: String!
  scale: Int!
}

enum LiquidityError {
  AlreadyCommitted
  AlreadyRolledBack
  InsufficientBalance
  InvalidId
  TransferExists
  UnknownAsset
  UnknownPeer
  UnknownTransfer
}

type Peer {
  id: ID!
  maxPacketAmount: UInt64
  http: Http!
  asset: Asset!
  staticIlpAddress: String!
}

type Http {
  outgoing: HttpOutgoing!
}

type HttpOutgoing {
  authToken: String!
  endpoint: String!
}

type Account {
  id: ID!
  asset: Asset!
  invoices(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): InvoiceConnection
  outgoingPayments(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): OutgoingPaymentConnection
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge!]!
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type Invoice {
  id: ID!
  maximumAmount: UInt64
  active: Boolean!
  createdAt: String!
  expiresAt: String
  description: String
  amountToReceive: UInt64
}

type OutgoingPaymentConnection {
  pageInfo: PageInfo!
  edges: [OutgoingPaymentEdge!]!
}

type OutgoingPaymentEdge {
  node: OutgoingPayment!
  cursor: String!
}

type OutgoingPayment {
  id: ID!
  state: PaymentState!
  error: String
  stateAttempts: Int!
  intent: PaymentIntent
  quote: PaymentQuote
  destinationAccount: PaymentDestinationAccount!
  outcome: OutgoingPaymentOutcome
  createdAt: String!
}

type PaymentIntent {
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

enum PaymentState {
  "Will transition to READY when quote is complete"
  QUOTING
  "Will transition to SENDING once payment funds are reserved"
  READY
  "Paying, will transition to COMPLETED on success"
  SENDING
  "Payment aborted; can be requoted to QUOTING"
  CANCELLED
  "Successfuly completion"
  COMPLETED
}

enum PaymentType {
  FIXED_SEND
  FIXED_DELIVERY
}

type PaymentQuote {
  timestamp: String!
  activationDeadline: String!
  targetType: PaymentType!
  minDeliveryAmount: UInt64!
  maxSourceAmount: UInt64!
  maxPacketAmount: UInt64!
  minExchangeRate: Float!
  lowExchangeRateEstimate: Float!
  highExchangeRateEstimate: Float!
}

type PaymentDestinationAccount {
  scale: Int!
  code: String!
  url: String
}

type OutgoingPaymentOutcome {
  amountSent: UInt64!
}

input CreateOutgoingPaymentInput {
  accountId: String!
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

type OutgoingPaymentResponse {
  code: String!
  success: Boolean!
  message: String
  payment: OutgoingPayment
}

input CreateAccountInput {
  asset: AssetInput!
}

type CreateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type CreatePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  peer: Peer
}

type UpdatePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  peer: Peer
}

type DeletePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type TransferMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type LiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

interface MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

scalar UInt64
