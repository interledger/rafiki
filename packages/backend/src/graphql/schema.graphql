type Query {
  outgoingPayment(id: String!): OutgoingPayment

  account(id: String!): Account

  peer(id: String!): Peer

  "Fetch a page of peers."
  peers(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): PeersConnection!
}

type Mutation {
  createOutgoingPayment(
    input: CreateOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Requote a Cancelled payment."
  requoteOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Add liquidity to a Funding payment."
  fundOutgoingPayment(
    input: FundOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Cancel a Funding payment."
  cancelOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!

  createAccount(input: CreateAccountInput!): CreateAccountMutationResponse!

  "Create peer"
  createPeer(input: CreatePeerInput!): CreatePeerMutationResponse!

  "Update peer"
  updatePeer(input: UpdatePeerInput!): UpdatePeerMutationResponse!

  "Delete peer"
  deletePeer(id: String!): DeletePeerMutationResponse!

  "Transfer between accounts"
  transfer(
    sourceAmount: UInt64!
    sourceAccountId: ID!
    destinationAccountId: ID!
    destinationAmount: UInt64
    autoCommit: Boolean
    idempotencyKey: ID!
  ): TransferMutationResponse

  "Add peer liquidity"
  addPeerLiquidity(input: AddPeerLiquidityInput!): LiquidityMutationResponse

  "Add asset liquidity"
  addAssetLiquidity(input: AddAssetLiquidityInput!): LiquidityMutationResponse

  "Create liquidity withdrawal from peer"
  createPeerLiquidityWithdrawal(
    input: CreatePeerLiquidityWithdrawalInput!
  ): LiquidityMutationResponse

  "Create liquidity withdrawal from asset"
  createAssetLiquidityWithdrawal(
    input: CreateAssetLiquidityWithdrawalInput!
  ): LiquidityMutationResponse

  "Finalize liquidity withdrawal"
  finalizeLiquidityWithdrawal(
    "The id of the liquidity withdrawal to finalize."
    withdrawalId: String!
  ): LiquidityMutationResponse

  "Rollback liquidity withdrawal"
  rollbackLiquidityWithdrawal(
    "The id of the liquidity withdrawal to rollback."
    withdrawalId: String!
  ): LiquidityMutationResponse

  "Create API Key"
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyMutationResponse

  "Delete all API Keys"
  deleteAllApiKeys(
    input: DeleteAllApiKeysInput!
  ): DeleteAllApiKeysMutationResponse

  "Redeem API Key"
  redeemApiKey(input: RedeemApiKeyInput!): RedeemApiKeyMutationResponse

  "Refresh Session"
  refreshSession(input: RefreshSessionInput!): RefreshSessionMutationResponse

  "Revoke Session"
  revokeSession(input: RevokeSessionInput!): RevokeSessionMutationResponse
}

type PageInfo {
  "Paginating forwards: the cursor to continue."
  endCursor: String
  "Paginating forwards: Are there more pages?"
  hasNextPage: Boolean!
  "Paginating backwards: Are there more pages?"
  hasPreviousPage: Boolean!
  "Paginating backwards: the cursor to continue."
  startCursor: String
}

type PeersConnection {
  pageInfo: PageInfo!
  edges: [PeerEdge!]!
}

type PeerEdge {
  node: Peer!
  cursor: String!
}

input CreatePeerInput {
  maxPacketAmount: UInt64
  http: HttpInput!
  asset: AssetInput!
  staticIlpAddress: String!
}

input UpdatePeerInput {
  id: String!
  maxPacketAmount: UInt64
  http: HttpInput
  staticIlpAddress: String
}

input HttpInput {
  incoming: HttpIncomingInput
  outgoing: HttpOutgoingInput!
}

input HttpIncomingInput {
  authTokens: [String!]!
}

input HttpOutgoingInput {
  authToken: String!
  endpoint: String!
}

input AssetInput {
  code: String!
  scale: Int!
}

input FundOutgoingPaymentInput {
  "The id of the outgoing payment to add liquidity."
  id: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  transferId: String!
}

input AddPeerLiquidityInput {
  "The id of the peer to add liquidity."
  peerId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String!
}

input AddAssetLiquidityInput {
  "The id of the asset to add liquidity."
  assetId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String!
}

input CreatePeerLiquidityWithdrawalInput {
  "The id of the peer to create the withdrawal for."
  peerId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

input CreateAssetLiquidityWithdrawalInput {
  "The id of the asset to create the withdrawal for."
  assetId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

input CreateApiKeyInput {
  "Account API key is created for."
  accountId: String!
}

input DeleteAllApiKeysInput {
  "Account API keys are deleted from."
  accountId: String!
}

input RedeemApiKeyInput {
  "API key"
  key: String!
  "Account API key was issued for."
  accountId: String!
}

input RefreshSessionInput {
  "Session key"
  key: String!
}

input RevokeSessionInput {
  "Session key"
  key: String!
}

type Asset {
  code: String!
  scale: Int!
}

enum LiquidityError {
  AlreadyCommitted
  AlreadyRolledBack
  InsufficientBalance
  InvalidId
  TransferExists
  UnknownAsset
  UnknownPeer
  UnknownTransfer
}

type Peer {
  id: ID!
  maxPacketAmount: UInt64
  http: Http!
  asset: Asset!
  staticIlpAddress: String!
}

type Http {
  outgoing: HttpOutgoing!
}

type HttpOutgoing {
  authToken: String!
  endpoint: String!
}

type Account {
  id: ID!
  asset: Asset!
  invoices(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): InvoiceConnection
  outgoingPayments(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): OutgoingPaymentConnection
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge!]!
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type Invoice {
  id: ID!
  active: Boolean!
  createdAt: String!
  expiresAt: String!
  description: String
  amount: UInt64!
}

type OutgoingPaymentConnection {
  pageInfo: PageInfo!
  edges: [OutgoingPaymentEdge!]!
}

type OutgoingPaymentEdge {
  node: OutgoingPayment!
  cursor: String!
}

type OutgoingPayment {
  id: ID!
  accountId: ID!
  state: PaymentState!
  error: String
  stateAttempts: Int!
  intent: PaymentIntent
  quote: PaymentQuote
  destinationAccount: PaymentDestinationAccount!
  outcome: OutgoingPaymentOutcome
  createdAt: String!
}

type PaymentIntent {
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

enum PaymentState {
  "Will transition to FUNDING or SENDING (if already funded) when quote is complete"
  QUOTING
  "Will transition to SENDING once payment funds are reserved"
  FUNDING
  "Paying, will transition to COMPLETED on success"
  SENDING
  "Payment aborted; can be requoted to QUOTING"
  CANCELLED
  "Successfuly completion"
  COMPLETED
}

enum PaymentType {
  FIXED_SEND
  FIXED_DELIVERY
}

type PaymentQuote {
  timestamp: String!
  activationDeadline: String!
  targetType: PaymentType!
  minDeliveryAmount: UInt64!
  maxSourceAmount: UInt64!
  maxPacketAmount: UInt64!
  minExchangeRate: Float!
  lowExchangeRateEstimate: Float!
  highExchangeRateEstimate: Float!
}

type PaymentDestinationAccount {
  scale: Int!
  code: String!
  url: String
}

type OutgoingPaymentOutcome {
  amountSent: UInt64!
}

input CreateOutgoingPaymentInput {
  accountId: String!
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

type OutgoingPaymentResponse {
  code: String!
  success: Boolean!
  message: String
  payment: OutgoingPayment
}

input CreateAccountInput {
  asset: AssetInput!
}

type ApiKey {
  id: ID!
  accountId: String!
  key: String!
  createdAt: String!
  updatedAt: String!
}

type Session {
  key: String!
  expiresAt: String!
}

type CreateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type CreatePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  peer: Peer
}

type UpdatePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  peer: Peer
}

type DeletePeerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type TransferMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type LiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type CreateApiKeyMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  apiKey: ApiKey
}

type DeleteAllApiKeysMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type RedeemApiKeyMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  session: Session
}

type RefreshSessionMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  session: Session
}

type RevokeSessionMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

interface MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

scalar UInt64

directive @auth on OBJECT | FIELD_DEFINITION
directive @isAdmin on OBJECT | FIELD_DEFINITION
