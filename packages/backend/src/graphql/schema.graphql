type Query {
  account(id: String!): Account

  "Fetch a page of accounts."
  accounts(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): AccountsConnection!

  outgoingPayment(id: String!): OutgoingPayment

  "Get a webhook by ID."
  webhook("The ID of the webhook to get." id: String!): Webhook!
}

type Mutation {
  "Create account"
  createAccount(input: CreateAccountInput!): CreateAccountMutationResponse!

  "Update account"
  updateAccount(input: UpdateAccountInput!): UpdateAccountMutationResponse!

  "Delete account"
  deleteAccount(id: String!): DeleteAccountMutationResponse!

  createOutgoingPayment(
    input: CreateOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Approve a Ready payment's quote."
  approveOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Requote a Cancelled payment."
  requoteOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Cancel a Ready payment."
  cancelOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!

  "Transfer between accounts"
  transfer(
    sourceAmount: UInt64!
    sourceAccountId: ID!
    destinationAccountId: ID!
    destinationAmount: UInt64
    autoCommit: Boolean
    idempotencyKey: ID!
  ): TransferMutationResponse

  "Create webhook"
  createWebhook(
    "The id of the account to create the webhook for."
    ilpAccountId: String!
  ): CreateWebhookMutationResponse

  "Update webhook"
  updateWebhook(
    "The id of the webhook to update."
    webhookId: ID!
  ): UpdateWebhookMutationResponse

  "Delete webhook"
  deleteWebhook(
    "The id of the webhook to delete."
    webhookId: ID!
  ): DeleteWebhookMutationResponse

  "Add account liquidity"
  addAccountLiquidity(
    input: AddAccountLiquidityInput!
  ): AddAccountLiquidityMutationResponse

  "Add asset liquidity"
  addAssetLiquidity(
    input: AddAssetLiquidityInput!
  ): AddAssetLiquidityMutationResponse

  "Create liquidity withdrawal from account"
  createAccountLiquidityWithdrawal(
    input: CreateAccountLiquidityWithdrawalInput!
  ): CreateAccountLiquidityWithdrawalMutationResponse

  "Create liquidity withdrawal from asset"
  createAssetLiquidityWithdrawal(
    input: CreateAssetLiquidityWithdrawalInput!
  ): CreateAssetLiquidityWithdrawalMutationResponse

  "Finalize liquidity withdrawal"
  finalizeLiquidityWithdrawal(
    "The id of the liquidity withdrawal to finalize."
    withdrawalId: String!
  ): FinalizeLiquidityWithdrawalMutationResponse

  "Rollback liquidity withdrawal"
  rollbackLiquidityWithdrawal(
    "The id of the liquidity withdrawal to rollback."
    withdrawalId: String!
  ): RollbackLiquidityWithdrawalMutationResponse
}

type PageInfo {
  "Paginating forwards: the cursor to continue."
  endCursor: String
  "Paginating forwards: Are there more pages?"
  hasNextPage: Boolean!
  "Paginating backwards: Are there more pages?"
  hasPreviousPage: Boolean!
  "Paginating backwards: the cursor to continue."
  startCursor: String
}

type AccountsConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge!]!
}

type AccountEdge {
  node: Account!
  cursor: String!
}

input CreateAccountInput {
  id: String
  disabled: Boolean
  maxPacketAmount: UInt64
  http: HttpInput
  asset: AssetInput!
  stream: StreamInput
  routing: RoutingInput
}

input UpdateAccountInput {
  id: String!
  disabled: Boolean
  maxPacketAmount: UInt64
  http: HttpInput
  stream: StreamInput
  routing: RoutingInput
}

input HttpInput {
  incoming: HttpIncomingInput!
  outgoing: HttpOutgoingInput!
}

input HttpIncomingInput {
  authTokens: [String!]!
}

input HttpOutgoingInput {
  authToken: String!
  endpoint: String!
}

input AssetInput {
  code: String!
  scale: Int!
}

input StreamInput {
  enabled: Boolean!
}

input RoutingInput {
  staticIlpAddress: String!
}

input AddAccountLiquidityInput {
  "The id of the account to add liquidity."
  accountId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input AddAssetLiquidityInput {
  "The id of the asset to add liquidity."
  assetId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input CreateAccountLiquidityWithdrawalInput {
  "The id of the account to create the withdrawal for."
  accountId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

input CreateAssetLiquidityWithdrawalInput {
  "The id of the asset to create the withdrawal for."
  assetId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

type Asset {
  code: String!
  scale: Int!
}

enum LiquidityError {
  AlreadyFinalized
  AlreadyRolledBack
  InsufficientBalance
  InvalidId
  TransferExists
  UnknownAccount
  UnknownAsset
  UnknownWithdrawal
}

type Account {
  id: ID!
  disabled: Boolean!
  maxPacketAmount: UInt64
  http: Http
  asset: Asset!
  stream: Stream!
  routing: Routing

  balance: UInt64
  invoices(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): InvoiceConnection
  webhooks(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): WebhooksConnection
}

type Http {
  outgoing: HttpOutgoing!
}

type HttpOutgoing {
  authToken: String!
  endpoint: String!
}

type Stream {
  enabled: Boolean!
}

type Routing {
  staticIlpAddress: String!
  inheritFromRemote: Boolean
  dynamicIlpAddress: String
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge!]!
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type Invoice {
  id: ID!
  maximumAmount: UInt64
  active: Boolean!
  createdAt: String!
  expiresAt: String
  description: String
}

interface AccountHolder {
  account: Account
}

type OutgoingPayment implements AccountHolder {
  id: ID!
  state: PaymentState!
  error: String
  stateAttempts: Int!
  intent: PaymentIntent
  quote: PaymentQuote
  accountId: ID!
  account: Account
  sourceAccountId: ID!
  destinationAccount: PaymentDestinationAccount!
  outcome: OutgoingPaymentOutcome
  createdAt: String!
}

type PaymentIntent {
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

enum PaymentState {
  "Will transition to READY when quote is complete"
  INACTIVE
  "Quote ready; awaiting user approval (ACTIVATED) or refusal (CANCELLING)"
  READY
  "Will transition to SENDING once payment funds are reserved"
  ACTIVATED
  "Paying, will transition to COMPLETED on success"
  SENDING
  "Will transition to CANCELLED when reserved funds are rolled back"
  CANCELLING
  "Payment aborted; can be requoted to INACTIVE"
  CANCELLED
  "Successfuly completion"
  COMPLETED
}

enum PaymentType {
  FIXED_SEND
  FIXED_DELIVERY
}

type PaymentQuote {
  timestamp: String!
  activationDeadline: String!
  targetType: PaymentType!
  minDeliveryAmount: UInt64!
  maxSourceAmount: UInt64!
  maxPacketAmount: UInt64!
  minExchangeRate: Float!
  lowExchangeRateEstimate: Float!
  highExchangeRateEstimate: Float!
}

type PaymentDestinationAccount {
  scale: Int!
  code: String!
  url: String
}

type OutgoingPaymentOutcome {
  amountSent: UInt64!
}

input CreateOutgoingPaymentInput {
  sourceAccountId: String!
  assetId: String!
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

type OutgoingPaymentResponse {
  code: String!
  success: Boolean!
  message: String
  payment: OutgoingPayment
}

type WebhooksConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge!]!
}

type WebhookEdge {
  node: Webhook!
  cursor: String!
}

type Webhook {
  id: ID!
}

type CreateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type UpdateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type DeleteAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type TransferMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type CreateWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  webhook: Webhook!
}

type UpdateWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  webhook: Webhook!
}

type DeleteWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type AddAccountLiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type AddAssetLiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type CreateAccountLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type CreateAssetLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type FinalizeLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type RollbackLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

interface MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

scalar UInt64
